<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link
rel="stylesheet" type="text/css"
id="ss"
href="../../../assets/css/common.css"
/>
<title>TLA+ Proof System</title>
</head>
<body>


<div id="wrapper">
  <div id="header">
    <div id="title">
      <a class="title"
        href="../../Home.html">
            TLA+ Proof System
      </a>
    </div>
    <div class="logomsr">
      <a href="https://www.msr-inria.inria.fr">
        <img
            src="../../../assets/images/logo-MS-Research-Inria-Joint-Centre-Small.png"
            alt="Microsoft Research - Inria Joint Centre"
            class="logo"
        />
      </a>
    </div>
  </div>
  <ul id="nav">


            <li>
                <a class="off"
                    href="../../Home.html">
                    Home
                </a>
            </li>
            

            <li>
                <a class="off"
                    href="../../Download.html">
                    Download
                </a>
            </li>
            

            <li>
                <a class="off"
                    href="../../Documentation.html">
                    Documentation
                </a>
            </li>
            

            <li>
                <a class="off"
                    href="../../Community.html">
                    Community
                </a>
            </li>
            

</ul>
<div id="transp"></div>
<div id="content" class="clearfix">
  <div id="col_1">

      <h2>Menu</h2>
      <ul id="menu">

            <li class="menuoff">
                <a
                    href="../../documentation/Tutorial.html">
                    Tutorial
                </a>
            </li>
            

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/The_example.html">
                        The example
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/A_simple_proof.html">
                        A simple proof
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/Hierarchical_proofs.html">
                        Hierarchical proofs
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/Advanced_options.html">
                        Advanced options
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/Other_proof_constructs.html">
                        Other proof constructs
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/Tactics.html">
                        Tactics
                    </a>
                </li>
                

                <li class="indexoff">
                    <a
                        href="../../documentation/tutorial/Practical_hints.html">
                        Practical hints
                    </a>
                </li>
                

            <li class="menuoff">
                <a
                    href="../../documentation/Unsupported_features.html">
                    Unsupported features
                </a>
            </li>
            

            <li class="menuoff">
                <a
                    href="../../documentation/Publications.html">
                    Publications
                </a>
            </li>
            

            <li class="menuoff">
                <a
                    href="../../documentation/TLA+_Hyperbook.html">
                    TLA+ Hyperbook
                </a>
            </li>
            

            <li class="menuoff">
                <a
                    href="../../documentation/TLA+_Video_Course.html">
                    TLA+ Video Course
                </a>
            </li>
            

            <li class="menuoff">
                <a
                    href="../../documentation/Misc.html">
                    Misc
                </a>
            </li>
            

</ul>
</div>
<div id="col_2">

<h2 id="hints-on-using-tlaps-effectively">Hints on using TLAPS effectively</h2>
<div class="hr"></div>

<p>The TLA+ proof system is designed to check the validity of claims as independently as possible of specific proof back-ends. We believe that users should concentrate on writing proofs in terms of their particular applications, not in terms of the capabilities of a particular proof system. In particular, TLAPS invokes its back-ends with some default setup for automatic proof, and we try to make it hard for users to change this default setup. Expert users of back-end provers may be frustrated because they may have to develop proofs somewhat further than what would be necessary with a fine-tuned tactic script. The main payoff of limited access to the nitty-gritty details of provers is greater clarity of the resulting proofs. They are also easier to maintain across minor changes of the specification or new releases of the TLA prover.</p>
<p>On some occasions users will encounter situations where the prover cannot prove an "obvious" proof obligation. Here are a few hints on what to try to make the proof go through. Your additions to this list are welcome.</p>
<h3 id="control-the-size-of-formulas-and-expressions">Control the size of formulas and expressions</h3>
<div class="hr"></div>

<p>Our provers are currently not good at making abstractions that humans understand immediately. They are easily confused by moderately big proof obligations and are just as likely to work on a top-level conjunction as on a set construction buried deeply inside the formula. This can cause back-ends to become very slow or even unable to complete seemingly trivial steps. While we intend to improve the back-ends in this respect, you can help them by using local definitions in proofs and hiding these definitions in order to keep expressions small. (Keep in mind that definitions introduced in a proof are usable by default and must be hidden explicitly, unlike definitions in specifications, which must be explicitly <code>USE</code>d.)</p>
<p>Here is a contrived example:</p>
<pre class="tla"><code><span class="purple">LEMMA</span>   /\ x \in SomeVeryBigExpression
        /\ y \in AnotherBigExpression
    &lt;=&gt;
        /\ y \in AnotherBigExpression
        /\ x \in SomeVeryBigExpression
&lt;1&gt; <span class="purple"><span class="purple">DEF</span><span class="purple">IN</span>E</span> S == SomeVeryBigExpression
    <span class="comment">\** here and in the following, you may use positional names</span>
    <span class="comment">\** to avoid repeating the big expressions</span>
&lt;1&gt; <span class="purple"><span class="purple">DEF</span><span class="purple">IN</span>E</span> T == AnotherBigExpression
&lt;1&gt;1. x \in S &lt;=&gt; x \in SomeVeryBigExpression
  <span class="purple">OBVIOUS</span>
&lt;1&gt;2. y \in T &lt;=&gt; y \in AnotherBigExpression
  <span class="purple">OBVIOUS</span>
&lt;1&gt; <span class="purple">HIDE</span> <span class="purple">DEF</span> S, T
&lt;1&gt;3.   /\ x \in S
        /\ y \in T
    &lt;=&gt;
        /\ y \in T
        /\ x \in S
  <span class="purple">OBVIOUS</span>
&lt;1&gt;4. <span class="purple">QED</span>
  <span class="purple">BY</span> &lt;1&gt;1, &lt;1&gt;2, &lt;1&gt;3
</code></pre>
<p>This kind of problem typically arises when reasoning about <code>LET</code> expressions, which are silently expanded by the proof manager. In a proof, introduce local definitions corresponding to the <code>LET</code> (using copy and paste from the specification), show that the overall expression equals the body of the <code>LET</code>, establish the necessary facts about these locally defined operators, and <code>HIDE</code> the definitions afterwards.</p>
<h3 id="avoid-circular-sets-of-equations">Avoid "circular" (sets of) equations</h3>
<div class="hr"></div>

<p>Rewriting is one effective way to reason about equations, and it underlies the automatic proof methods used by the Isabelle back-end. The basic idea is to orient equalities such that the expressions on the left-hand side are systematically replaced by the right-hand sides. However, if the set of equations contains cycles as in</p>
<pre class="tla"><code>s = f(t)
t = g(s)
</code></pre>
<p>then rewriting may never terminate. Isabelle employs some (incomplete) heuristics to detect such cycles and will refuse to rewrite equations that it determines to be circular. This usually leads to its inability to infer anything about these equations. If circularity is not detected, it may cause Isabelle to enter an infinite loop. The suggested remedy is again to introduce local definitions that are hidden to break the loops.</p>
<p>As a concrete example consider the following proof snippet:</p>
<pre class="tla"><code>  &lt;4&gt;17. foo.name = &quot;xyz&quot;
    &lt;5&gt;1. foo = [name |-&gt; &quot;xyz&quot;, value |-&gt; foo.value]
      <span class="purple">BY</span> &lt;2&gt;2
    &lt;5&gt;2. <span class="purple">QED</span>
      <span class="purple">BY</span> &lt;5&gt;1  <span class="comment">\** may not work because &lt;5&gt;1 is a circular equation</span>
</code></pre>
<p>One possible workaround is as follows:</p>
<pre class="tla"><code>  &lt;4&gt;17. foo.name = &quot;xyz&quot;
    &lt;5&gt;   fooval == foo.value
    &lt;5&gt;1. foo = [name |-&gt; &quot;xyz&quot;, value |-&gt; fooval]
      <span class="purple">BY</span> &lt;2&gt;2
    &lt;5&gt;   <span class="purple">HIDE</span> <span class="purple">DEF</span> fooval
    &lt;5&gt;2. <span class="purple">QED</span>
      <span class="purple">BY</span> &lt;5&gt;1
</code></pre>
<h3 id="using-set-extensionality">Using set extensionality</h3>
<div class="hr"></div>

<p>The theorem of set extensionality asserts that two sets are equal if they contain the same elements:</p>
<pre class="tla"><code><span class="purple">THEOREM</span> SetExtensionality == \A S,T : (\A x : x \in S &lt;=&gt; x \in T) =&gt; S = T
</code></pre>
<p>This theorem is defined in the standard module TLAPS and can be proved automatically in TLAPS. Nevertheless, it is sometimes necessary to appeal to that theorem for proving that two set expressions are equal. Making set extensionality a part of the background theory would be counter-productive, since it could be applied to many occurrences of the equality symbol. When necessary, it can be added explicitly in a BY clause for the SMT backend. For Isabelle proofs, TLAPS defines a specific pragma <code>IsaWithSetExtensionality</code> that instructs Isabelle to try applying the set extensionality rule for proving equality of sets.</p>
<h3 id="reasoning-about-choose-expressions">Reasoning about CHOOSE expressions</h3>
<div class="hr"></div>

<p>Consider a definition such as</p>
<pre class="tla"><code>foo == <span class="purple">CHOOSE</span> x \in S : P(x)
</code></pre>
<p>In order to prove a property <code>Q(foo)</code>, you will typically prove the two following assertions:</p>
<p>a. <code>\E x \in S : P(x)</code> b. <code>\A x \in S : P(x) =&gt; Q(x)</code></p>
<p>In some cases, assertion (b) can be trivial and need not be shown explicitly. Reasoning about an unbounded <code>CHOOSE</code> expression is analogous.</p>
<p>Remember that <code>CHOOSE</code> always denotes some value, even if <code>P(x)</code> holds for no <code>x \in S (in particular, if S = {})</code>, in which case the <code>CHOOSE</code> expression is fixed, but arbitrary. In practice, <code>CHOOSE</code> expressions usually arise when condition (a) is satisfied. Should you have designed your property to work even if the domain of the <code>CHOOSE</code> is empty, property <code>Q</code> must be trivial in that case, and you can structure your proof as follows:</p>
<pre class="tla"><code>&lt;3&gt;5. Q(foo)
    &lt;4&gt;1. <span class="purple">CASE</span> \E x \in S : P(x)
      &lt;5&gt;1. \A x \in S : P(x) =&gt; Q(x)
      &lt;5&gt;2. <span class="purple">QED</span>
        <span class="purple">BY</span> &lt;4&gt;1, &lt;5&gt;1 <span class="purple">DEF</span> foo
    &lt;4&gt;2. <span class="purple">CASE</span> ~ \E x \in S : P(x)
      &lt;5&gt;1. \A x : Q(x)
      &lt;5&gt;2. <span class="purple">QED</span>
        <span class="purple">BY</span> &lt;5&gt;1
    &lt;4&gt;3. <span class="purple">QED</span>
      <span class="purple">BY</span> &lt;4&gt;1, &lt;4&gt;2
</code></pre>
<p>A frequent TLA+ idiom is to define a "null" value by writing</p>
<pre class="tla"><code>NoValue == <span class="purple">CHOOSE</span> x : x \notin Value
</code></pre>
<p>The laws of set theory ensure that no set is universal, hence there exists an <code>x</code> that is not an element of set <code>Value</code>, ensuring condition (a) above. The theorem <code>NoSetContainsEverything</code> in the standard module TLAPS can be used to prove this condition.</p>
<p>The SMT backend may fail to prove obligations involving several <code>CHOOSE</code> expressions. In particular, the axioms for determinacy of <code>CHOOSE</code> stating</p>
<pre class="tla"><code>(\A x : P(x) &lt;=&gt; Q(x))  =&gt;  (<span class="purple">CHOOSE</span> x : P(x)) = (<span class="purple">CHOOSE</span> x : Q(x))
</code></pre>
<p>may not be available to the SMT solver.</p>
<h3 id="help-zenon-and-isabelle-when-reasoning-about-records">Help Zenon and Isabelle When Reasoning About Records</h3>
<div class="hr"></div>

<p>In one proof, we had</p>
<pre class="tla"><code>mb == [type  |-&gt; &quot;1b&quot;, bal |-&gt; b, acc |-&gt; self,
       mCBal |-&gt; maxCBal[self], mCVal |-&gt; maxCVal[self]]
</code></pre>
<p>and were trying to prove</p>
<pre><code>m1 # mb /\ m2 # mb

<p>from facts that included</p>
<pre class="tla"><code>m1.type = &quot;2av&quot; /\ m2.type = &quot;2av&quot;
</code></pre>
<p>Zenon failed on the proof and Isabelle proved it only after a long time. (In fact, we originally stopped the proof because it was taking so long.) However, Zenon proved it instantly when we added <code>mb.type = "1b"</code> to the <code>BY</code> statement's list of facts. The provers are reluctant to try finding relations of the form <code>record.field = value</code>. They often need help.</p>
<p>The SMT backend should not require similar help for reasoning about records.</p>
<h3 id="divide-and-conquer">Divide and Conquer</h3>
<div class="hr"></div>

<p>When the provers can't prove something that you think is obvious, it's usually because it isn't true. You can easily spend hours looking at a proof obligation without noticing a tiny mistake. The best way to find a mistake is by breaking the proof into simpler steps. Continuing to do this on the step or steps whose proof fails will eventually lead you to discover the problem – usually a missing hypothesis or a mistake in a formula. When you correct the mistake in the original proof step, the prover will usually be able to prove it.</p>
<h3 id="dont-reinvent-mathematics">Don't Reinvent Mathematics</h3>
<div class="hr"></div>

<p>We expect that most people who use TLAPS will do so because they want to verify properties of an algorithm or system. We have therefore not devoted our limited resources to building libraries of mathematical results. If you want to create such libraries, we would welcome your help. However, if you are concerned with an algorithm or system, you should not be spending your time proving basic mathematical facts. Instead, you should assert the mathematical theorems you need as assumptions or theorems.</p>
<p>Asserting facts is dangerous, because it's easy to make a mistake and assert something false, making your entire proof unsound. Fortunately, you can use the TLC model checker to avoid such mistakes. For example, our example correctness proof of Euclid's algorithm uses this assumption</p>
<pre class="tla"><code><span class="purple">ASSUME</span> GCDProperty3 ==
       \A p, q \in Nat \ {0}: (p &lt; q) =&gt; GCD(p, q) = GCD(p, q-p)
</code></pre>
<p>TLC cannot check this assumption because it can't evaluate a quantification over an infinite set. However, you can tell TLC to replace the definition of <code>Nat</code> with</p>
<pre class="tla"><code>Nat == 0..50
</code></pre>
<p>(In the Toolbox, use the Definition Override section of the model's Advanced Options page.) TLC quickly verifies this assumption. (TLC checks each <code>ASSUME</code>; to add an assumption that you don't want TLC to check, make it an <code>AXIOM</code>.)</p>
<p>This kind of checking is almost certain to catch an error in expressing a fundamentally correct mathematical result – except when the only counterexamples are infinite. Fortunately, this is rarely the case when the result is needed for reasoning about an algorithm or system.</p>
<h3 id="its-easier-to-prove-something-if-its-true">It's Easier to Prove Something if it's True</h3>
<div class="hr"></div>

<p>Before trying to prove a property of an algorithm or system, try to check it with TLC. Even if TLC cannot check a large enough model to catch all errors, running it on a small model can still catch many simple errors. You will save a lot of time if you let TLC find these errors instead of discovering them while writing the proof.</p>
<!--
---- MODULE practical_hints ----
EXTENDS TLAPS, Naturals

---- MODULE control_the_size ----
CONSTANT x, y, SomeVeryBigExpression, AnotherBigExpression

LEMMA   /\ x \in SomeVeryBigExpression
        /\ y \in AnotherBigExpression
    <=>
        /\ y \in AnotherBigExpression
        /\ x \in SomeVeryBigExpression
<1> DEFINE S == SomeVeryBigExpression
    \** here and in the following, you may use positional names
    \** to avoid repeating the big expressions
<1> DEFINE T == AnotherBigExpression
<1>1. x \in S <=> x \in SomeVeryBigExpression
  OBVIOUS
<1>2. y \in T <=> y \in AnotherBigExpression
  OBVIOUS
<1> HIDE DEF S, T
<1>3.   /\ x \in S
        /\ y \in T
    <=>
        /\ y \in T
        /\ x \in S
  OBVIOUS
<1>4. QED
  BY <1>1, <1>2, <1>3

====
---- MODULE circular_equations ----

CONSTANT foo

(* circular equations
s = f(t)
t = g(s)
*)

THEOREM circular == TRUE
<1> TRUE
 <2>2 ASSUME TRUE PROVE TRUE
\* circular example 1
  <4>17. foo.name = "xyz"
    <5>1. foo = [name |-> "xyz", value |-> foo.value]
      BY <2>2
    <5>2. QED
      BY <5>1  \** may not work because <5>1 is a circular equation
  <4> QED
 <2> QED
<1> TRUE
 <2>2 ASSUME TRUE PROVE TRUE
\* circular example 2
  <4>17. foo.name = "xyz"
    <5>   fooval == foo.value
    <5>1. foo = [name |-> "xyz", value |-> fooval]
      BY <2>2
    <5>   HIDE DEF fooval
    <5>2. QED
      BY <5>1
  <4> QED
 <2> QED
<1> QED

====

(*
THEOREM SetExtensionality == \A S,T : (\A x : x \in S <=> x \in T) => S = T
*)

---- MODULE choose_example ----

CONSTANT P(_), Q(_), S, Value

foo == CHOOSE x \in S : P(x)

THEOREM choose_example == TRUE
<3>5. Q(foo)
    <4>1. CASE \E x \in S : P(x)
      <5>1. \A x \in S : P(x) => Q(x)
      <5>2. QED
        BY <4>1, <5>1 DEF foo
    <4>2. CASE ~ \E x \in S : P(x)
      <5>1. \A x : Q(x)
      <5>2. QED
        BY <5>1
    <4>3. QED
      BY <4>1, <4>2
<3> QED

NoValue == CHOOSE x : x \notin Value

AXIOM choose_determinacy ==
(\A x : P(x) <=> Q(x))  =>  (CHOOSE x : P(x)) = (CHOOSE x : Q(x))

====
---- MODULE record_example ----

CONSTANT maxCBal, maxCVal, self, b, m1, m2

mb == [type  |-> "1b", bal |-> b, acc |-> self,
       mCBal |-> maxCBal[self], mCVal |-> maxCVal[self]]

THEOREM records ==
ASSUME
m1.type = "2av" /\ m2.type = "2av"
PROVE
m1 # mb /\ m2 # mb

====
---- MODULE mathematics ----

CONSTANT GCD(_, _)

ASSUME GCDProperty3 ==
       \A p, q \in Nat \ {0}: (p < q) => GCD(p, q) = GCD(p, q-p)

(* restrict naturals
Nat == 0..50
*)
====
====
-->



    </div>
  </div>
</div>

</script>
</body>
</html>
